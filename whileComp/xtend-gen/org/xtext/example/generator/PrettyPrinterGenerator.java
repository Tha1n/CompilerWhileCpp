/**
 * generated by Xtext
 */
package org.xtext.example.generator;

import SymboleTable.Fonction;
import SymboleTable.FunDictionary;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Injector;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.xtext.example.WhileCppStandaloneSetup;
import org.xtext.example.whileCpp.Command;
import org.xtext.example.whileCpp.CommandForEach;
import org.xtext.example.whileCpp.CommandIf;
import org.xtext.example.whileCpp.CommandWhile;
import org.xtext.example.whileCpp.Commands;
import org.xtext.example.whileCpp.Definition;
import org.xtext.example.whileCpp.Expr;
import org.xtext.example.whileCpp.ExprAnd;
import org.xtext.example.whileCpp.ExprEq;
import org.xtext.example.whileCpp.ExprNot;
import org.xtext.example.whileCpp.ExprOr;
import org.xtext.example.whileCpp.ExprSimple;
import org.xtext.example.whileCpp.Exprs;
import org.xtext.example.whileCpp.Function;
import org.xtext.example.whileCpp.Input;
import org.xtext.example.whileCpp.Output;
import org.xtext.example.whileCpp.Program;
import org.xtext.example.whileCpp.Vars;

/**
 * Generates code from your model files on save.
 * 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class PrettyPrinterGenerator implements IGenerator {
  private FunDictionary dico = new FunDictionary();
  
  private int ibd = 1;
  
  private int ibif = 1;
  
  private int ibforeach = 1;
  
  private int ibwhile = 1;
  
  private int portee = 0;
  
  public List<String> getFunctionsNames() {
    List<String> _listFuncName = this.dico.getListFuncName();
    return IterableExtensions.<String>toList(_listFuncName);
  }
  
  public List<Fonction> getFunctions() {
    return this.dico.getFunctions();
  }
  
  public void resetDico() {
    FunDictionary _funDictionary = new FunDictionary();
    this.dico = _funDictionary;
  }
  
  public Set<String> getVariables(final int fn) {
    List<Fonction> _functions = this.dico.getFunctions();
    Fonction _get = _functions.get(fn);
    List<String> _listVarName = _get.getListVarName();
    return IterableExtensions.<String>toSet(_listVarName);
  }
  
  public void parseMap(final Map<String, Integer> indent) {
    Integer _get = indent.get("All");
    boolean _notEquals = (!Objects.equal(_get, null));
    if (_notEquals) {
      Integer _get_1 = indent.get("All");
      this.ibd = (_get_1).intValue();
      this.ibif = this.ibd;
      this.ibforeach = this.ibif;
      this.ibwhile = this.ibif;
    }
    Integer _get_2 = indent.get("If");
    boolean _notEquals_1 = (!Objects.equal(_get_2, null));
    if (_notEquals_1) {
      Integer _get_3 = indent.get("If");
      this.ibif = (_get_3).intValue();
    }
    Integer _get_4 = indent.get("While");
    boolean _notEquals_2 = (!Objects.equal(_get_4, null));
    if (_notEquals_2) {
      Integer _get_5 = indent.get("While");
      this.ibwhile = (_get_5).intValue();
    }
    Integer _get_6 = indent.get("Foreach");
    boolean _notEquals_3 = (!Objects.equal(_get_6, null));
    if (_notEquals_3) {
      Integer _get_7 = indent.get("Foreach");
      this.ibforeach = (_get_7).intValue();
    }
  }
  
  public void generate(final String in, final String outputFile, final Map<String, Integer> indentation, final Integer width) {
    this.resetDico();
    WhileCppStandaloneSetup _whileCppStandaloneSetup = new WhileCppStandaloneSetup();
    final Injector injector = _whileCppStandaloneSetup.createInjectorAndDoEMFRegistration();
    final XtextResourceSet resourceSet = injector.<XtextResourceSet>getInstance(XtextResourceSet.class);
    final URI uri = URI.createURI(in);
    final Resource xtextResource = resourceSet.getResource(uri, true);
    EcoreUtil.resolveAll(xtextResource);
    this.parseMap(indentation);
    String out = outputFile;
    boolean _equals = out.equals("");
    if (_equals) {
      out = (in + "pp");
    }
    try {
      final FileWriter fstream = new FileWriter(out);
      final BufferedWriter buff = new BufferedWriter(fstream);
      TreeIterator<EObject> _allContents = xtextResource.getAllContents();
      Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
      Iterable<Program> _filter = Iterables.<Program>filter(_iterable, Program.class);
      for (final Program p : _filter) {
        CharSequence _compile = this.compile(p, 0);
        String _string = _compile.toString();
        buff.write(_string);
      }
      buff.close();
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        String _message = e.getMessage();
        String _plus = ((("Can\'t write " + out) + " - Error: ") + _message);
        InputOutput.<String>println(_plus);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public CharSequence indent(final int level) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�FOR i : 1..level��IF level>0��FOR j : 1..ibd��\" \"��ENDFOR��ENDIF��ENDFOR�");
    return _builder;
  }
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    this.resetDico();
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<Program> _filter = Iterables.<Program>filter(_iterable, Program.class);
    for (final Program p : _filter) {
      CharSequence _compile = this.compile(p, 0);
      fsa.generateFile("PP.wh", _compile);
    }
  }
  
  public CharSequence compile(final Program p, final int indent) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)��FOR f: p.fonctions�");
    _builder.newLine();
    _builder.append("�f.compile(indent)�");
    _builder.newLine();
    _builder.append("�indent(indent)��ENDFOR�");
    return _builder;
  }
  
  public CharSequence compile(final Function f, final int indent) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)�function �f.nom�:");
    _builder.newLine();
    _builder.append("�var newF = new Fonction(f.nom,f.definition.inputs.varIn.size,f.definition.outputs.varOut.size,\"nomFonctionCible\")�");
    _builder.newLine();
    _builder.append("�IF dico.putFunction(newF)�");
    _builder.newLine();
    _builder.append("�f.definition.compile(indent, newF)�");
    _builder.newLine();
    _builder.append("�ELSE � ERREUR: FONCTION �f.nom � D�J� D�CLAR�E");
    _builder.newLine();
    _builder.append("�ENDIF�");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compile(final Definition d, final int indent, final Fonction f) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)�read �d.inputs.compile(0, f)�");
    _builder.newLine();
    _builder.append("�indent(indent)�%");
    _builder.newLine();
    _builder.append("�d.commandes.compile(indent+1, f)�");
    _builder.newLine();
    _builder.append("�indent(indent)�%");
    _builder.newLine();
    _builder.append("�indent(indent)�write �d.outputs.compile(0, f)�");
    return _builder;
  }
  
  public CharSequence compile(final Input i, final int indent, final Fonction f) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)��FOR in : i.varIn��in��f.add(new Variable(in, \"input\"))��IF i.varIn.indexOf(in)!=i.varIn.size-1�, �ENDIF��ENDFOR�");
    return _builder;
  }
  
  public CharSequence compile(final Commands c, final int indent, final Fonction f) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�FOR cm: c.commande��cm.compile(indent, f)��IF c.commande.indexOf(cm)!=c.commande.size-1� ;");
    _builder.newLine();
    _builder.append("�ENDIF��ENDFOR�");
    return _builder;
  }
  
  public CharSequence compile(final Output o, final int indent, final Fonction f) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)��FOR in : o.varOut��in��IF o.varOut.indexOf(in)!=o.varOut.size-1�, �ENDIF��ENDFOR�");
    return _builder;
  }
  
  public CharSequence compile(final Command c, final int indent, final Fonction f) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�switch (c){");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("case c.nop!=null : indent(indent) + \"nop\"");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("case c.cmdIf!=null : c.cmdIf.compile(indent, f)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("case c.cmdForEach!=null : c.cmdForEach.compile(indent, f)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("case c.vars!=null && c.exprs!=null : c.vars.compile(indent, f) + \" := \" + c.exprs.compile(0)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("case c.cmdWhile!=null : c.cmdWhile.compile(indent, f)");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("default : c.class.name");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("�");
    return _builder;
  }
  
  public CharSequence compile(final CommandWhile c, final int indent, final Fonction f) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)��IF c.w!=null�while �ELSE�for �ENDIF��c.expr.compile(0)� do");
    _builder.newLine();
    _builder.append("�c.cmds.compile(indent+ibwhile, f)�");
    _builder.newLine();
    _builder.append("�indent(indent)�od");
    return _builder;
  }
  
  public CharSequence compile(final CommandIf c, final int indent, final Fonction f) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)�if �c.cond.compile(0)� then ");
    _builder.newLine();
    _builder.append("�c.cmdsThen.compile(indent+ibif, f)��IF c.cmdsElse!=null�");
    _builder.newLine();
    _builder.append("�indent(indent)�else");
    _builder.newLine();
    _builder.append("�c.cmdsElse.compile(indent+ibif, f)��ENDIF�");
    _builder.newLine();
    _builder.append("�indent(indent)�fi");
    return _builder;
  }
  
  public CharSequence compile(final CommandForEach c, final int indent, final Fonction f) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)�foreach �c.elem.compile(0)� in �c.ensemb.compile(0)� do\t");
    _builder.newLine();
    _builder.append("�c.cmds.compile(indent+ibforeach, f)�");
    _builder.newLine();
    _builder.append("�indent(indent)�od");
    return _builder;
  }
  
  public CharSequence compile(final Vars v, final int indent, final Fonction f) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)��FOR in : v.varGen��in��var vari = new Variable (in.toString, \"intern\")��dico.putVariable(vari, f)��IF v.varGen.indexOf(in)!=v.varGen.size-1�, �ENDIF��ENDFOR�");
    return _builder;
  }
  
  public CharSequence compile(final Exprs e, final int indent) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�FOR in : e.expGen��in.compile(indent)��IF e.expGen.indexOf(in)!=e.expGen.size-1�, �ELSE��ENDIF��ENDFOR�");
    return _builder;
  }
  
  public CharSequence compile(final Expr ex, final int indent) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�switch(ex){");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case ex.exprSimp!=null : ex.exprSimp.compile(indent)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("case ex.exprAnd!=null : ex.exprAnd.compile(indent)");
    _builder.newLine();
    _builder.append("\t    ");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("�");
    return _builder;
  }
  
  public CharSequence compile(final ExprSimple ex, final int indent) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)��switch(ex){");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("case ex.nil!=null : \"nil\"");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("case ex.vari!=null : ex.vari");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("case ex.symb!=null : ex.symb");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("case ex.exprCons!=null : \"(cons \" + consListRec(ex.exprCons.exprConsAttList.toList) + \")\"");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("//case ex.exprList!=null : \"(list \"+ ex.exprListAtt1.compile(0) + \" \" + ex.exprListAtt2.compile(0) + \")\"");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("case ex.exprHead!=null : \"(hd \"+ ex.exprHeadAtt.compile(0) + \")\"");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("case ex.exprTail!=null : \"(tl \" + ex.exprTailAtt.compile(0) +\")\"");
    _builder.newLine();
    _builder.append("\t \t");
    _builder.append("case ex.nomSymb!=null : \"(\" + ex.nomSymb + ex.symbAtt.compile(0) + \")\"");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("�");
    return _builder;
  }
  
  public CharSequence consListRec(final List<Expr> l) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�IF l.size == 2��l.head.compile(0) + l.get(1).compile(0)");
    _builder.newLine();
    _builder.append("��ELSE��");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("l.head.compile(0) \" (cons \" + consListRec((l.tail.toList)) + \")\"��");
    _builder.newLine();
    _builder.append("ENDIF�");
    return _builder;
  }
  
  public CharSequence compile(final ExprAnd ex, final int indent) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�ex.exprOr.compile(indent)��IF ex.exprAnd!=null��ex.exprAndAtt.compile(0)��ENDIF�");
    return _builder;
  }
  
  public CharSequence compile(final ExprOr ex, final int indent) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�ex.exprNot.compile(indent)��IF ex.exprOr!=null��ex.exprOrAtt.compile(0)��ENDIF�");
    return _builder;
  }
  
  public CharSequence compile(final ExprNot ex, final int indent) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)��IF ex.not!=null�not �ENDIF��ex.exprEq.compile(0)�");
    return _builder;
  }
  
  public CharSequence compile(final ExprEq ex, final int indent) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�indent(indent)��IF ex.expr!=null�(�ex.expr.compile(0)�)�ELSE��ex.exprSim1.compile(0)� =? �ex.exprSim2.compile(0)��ENDIF�");
    return _builder;
  }
}
