/*
 * generated by Xtext
 */
package org.xtext.example.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.xtext.example.whileCpp.Command
import org.xtext.example.whileCpp.CommandForEach
import org.xtext.example.whileCpp.CommandIf
import org.xtext.example.whileCpp.CommandWhile
import org.xtext.example.whileCpp.Commands
import org.xtext.example.whileCpp.Definition
import org.xtext.example.whileCpp.Expr
import org.xtext.example.whileCpp.ExprAnd
import org.xtext.example.whileCpp.ExprEq
import org.xtext.example.whileCpp.ExprNot
import org.xtext.example.whileCpp.ExprOr
import org.xtext.example.whileCpp.ExprSimple
import org.xtext.example.whileCpp.Exprs
import org.xtext.example.whileCpp.Function
import org.xtext.example.whileCpp.Input
import org.xtext.example.whileCpp.Output
import org.xtext.example.whileCpp.Program
import org.xtext.example.whileCpp.Vars
import org.eclipse.emf.common.util.URI
import org.xtext.example.WhileCppStandaloneSetup
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.emf.ecore.util.EcoreUtil
import SymboleTable.Fonction
import SymboleTable.Variable
import SymboleTable.FunDictionary
import java.util.Set
import java.util.List
import SymboleTable.Quadruplet
import SymboleTable.CodeOp
import java.util.HashMap
import java.util.ArrayList
import SymboleTable.Label
import java.io.FileWriter
import java.io.BufferedWriter

/**
 * Generates code from your model files on save.
 * 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ThreeAddGenerator implements IGenerator {
	
	FunDictionary dico = new FunDictionary();
	
	private ArrayList<Variable> m_globalVarList;
	private HashMap<String, String> funNameTranslation;
	private ArrayList<Label> m_labelList;
	private HashMap<String, Quadruplet> varNameTranslation;
	private int numVar;
	 
	def public List<String> getFunctionsNames()
	{
		return dico.listFuncName.toList
	}
	
	def public List<Fonction> getFunctions()
	{
		return dico.functions
	}
	
	def public void resetDico()
	{
		dico = new FunDictionary();
	}
	
	
	def public Set<String> getVariables(int fn)
	{
		return dico.functions.get(fn).listVarName.toSet
	} 

	
	def public String print3a(){
		var res = ""
		for(Fonction f : dico.functions){
			for(Quadruplet q : f.m_quadList){
				res +=(q.toString()+"\n");
			}
		}
		return res
	}	
	
	def public void generate(String in, FunDictionary tab3A)
	{
		resetDico
		val injector = new WhileCppStandaloneSetup().createInjectorAndDoEMFRegistration();
		val resourceSet = injector.getInstance(XtextResourceSet);
		val uri = URI.createURI(in);
		val xtextResource = resourceSet.getResource(uri, true);
		this.funNameTranslation = new HashMap<String, String>();
		this.varNameTranslation = new HashMap<String, Quadruplet>();
		this.numVar = -1
		this.m_globalVarList = new ArrayList<Variable>();
		this.m_labelList = new ArrayList<Label>();
		EcoreUtil.resolveAll(xtextResource);
		
		try{
  			val fstream = new FileWriter("PP.3a")
  			val buff = new BufferedWriter(fstream)
  			for(p: xtextResource.allContents.toIterable.filter(Program))
				buff.write(print3a())
  			buff.close()
  		}catch (Exception e){
  			println("Can't write PP.3a - Error: " + e.getMessage())
  		}
		
	}
	
	def public Label generateLabel() {
		val result = new Label("l_" + this.m_labelList.size());
		this.m_labelList.add(result);
		return result;
	}
	
	def public String generateVar() {
		this.numVar += 1
		"v_" + this.numVar
	}
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		
        resetDico
        
		this.funNameTranslation = new HashMap<String, String>();
		this.varNameTranslation = new HashMap<String, Quadruplet>();
		this.numVar = -1
		this.m_globalVarList = new ArrayList<Variable>();
		this.m_labelList = new ArrayList<Label>();
		for(p: resource.allContents.toIterable.filter(Program)) {
			fsa.generateFile("PP.3a", p.compile())
		}
	}

	def compile (Program p)
'''«FOR f: p.fonctions»
«f.compile()»
«ENDFOR»'''
//«print3a()»'''
	
	def compile (Function f)
	//Ajout de la fonction dans la liste puis ajout de son code 3A
'''«var newF = new Fonction(f.nom,f.definition.inputs.varIn.size,f.definition.outputs.varOut.size,"nomFonctionCible")»
«IF dico.putFunction(newF)»
«this.funNameTranslation.put(f.nom, "f"+this.funNameTranslation.size)»
«f.definition.compile(newF)»
«ELSE » ERREUR: FONCTION «f.nom » DÉJÀ DÉCLARÉE
«ENDIF»
'''

	def compile (Definition d, Fonction f)
	'''«d.inputs.compile(f)»
«d.commandes.compile(f, null)»
«d.outputs.compile(f)»'''
	
	def compile (Input i, Fonction f)
	//Gestion des variables While contenus dans le Read translate en var CPP
	'''«FOR in : i.varIn»«f.addReadVar(in.toString, generateVar)»«f.add(new Variable(in, "input"))»«IF i.varIn.indexOf(in)!=i.varIn.size-1»«ENDIF»«ENDFOR»'''
			
	def compile (Output o, Fonction f)
	'''«FOR out : o.varOut»«f.addQuad(new Quadruplet(new CodeOp(CodeOp.OP_WRITE), out.toString, "_", "_"))»«ENDFOR»'''
	
	def compile (Commands c, Fonction f, Label l)
	'''«IF c != null»«FOR cm: c.commande»«IF cm != null»«cm.compile(f, l)»«ENDIF»«ENDFOR»«ELSE»_«ENDIF»'''
	
	
	def compile(Command c, Fonction f, Label l)
'''«switch (c){
	case c.nop!=null : {
		val nop = new Quadruplet(new CodeOp(CodeOp.OP_NOP), "_", "_", "_")
		if(l==null)
		{
			f.addQuad(nop)
			print("[DBG]f += <NOP>\n")
		}
		else
		{
			l.add(nop)
			print("[DBG]" + l.name + " += <NOP>\n")
		}		 
	}
	case c.cmdIf!=null : 
	{
		val cond = c.cmdIf.cond.compile(f).toString
		//1. Generate if Label
		val ifLabel = generateLabel
		//2. Generate else Label
		val elseLabel = generateLabel
		
		val ifQuad = new Quadruplet(new CodeOp(CodeOp.OP_IF, ifLabel.name, elseLabel.name), "_", cond, "_");
		
		if(l==null)
		{
			f.addQuad(ifQuad)
			print("[DBG]f += <IF " + ifLabel.name + " " + elseLabel.name + ", _, " + cond + ", _>\n")
		}
		else
		{
			l.add(ifQuad)
			print("[DBG]" + l.name + " += <IF " + ifLabel.name + " " + elseLabel.name + ", _, " + cond + ", _>\n")
		}
		
		c.cmdIf.cmdsThen.compile(f, ifLabel)
		c.cmdIf.cmdsElse.compile(f, elseLabel)
	}
	case c.vars!=null && c.exprs!=null : 
	{
		val res = c.exprs.compile(f).toString
		val variable = c.vars.compile(f).toString()
		val affect = new Quadruplet(new CodeOp(CodeOp.OP_AFF), variable, res, "_")
		if(l==null)
		{
			f.addQuad(affect)
			print("[DBG]f += <:=, " + variable.trim + "," + res + ", _>\n")
		}
		else
		{
			l.add(affect)
			print("[DBG]" + l.name + " += <:=, " + variable.trim + "," + res + ", _>\n")
		}
	}
	case c.cmdWhile!=null : 
	{
		val whileLabel = generateLabel
		
		val expString = c.cmdWhile.expr.compile(f).toString
		
		val whileQuad = new Quadruplet(new CodeOp(CodeOp.OP_WHILE, whileLabel.name), "_", expString, "_");
		
		if(l==null)
		{
			f.addQuad(whileQuad)
			print("[DBG]f += <WHILE " + whileLabel.name + ", _, " + expString + ",_>\n")
		}
		else
		{
			l.add(whileQuad)
			print("[DBG]" + l.name + " += <WHILE " + whileLabel.name + ", _, " + expString + ",_>\n")
		}
		c.cmdWhile.cmds.compile(f, whileLabel)
	} 
	case c.cmdForEach!=null : 
	{
		val foreachLabel = generateLabel
		val elem = c.cmdForEach.elem.compile(f).toString
		val ensemble = c.cmdForEach.ensemb.compile(f).toString
		val whileQuad = new Quadruplet(new CodeOp(CodeOp.OP_FOREACH, foreachLabel.name), "_", elem, ensemble);
		
		if(l==null)
		{
			f.addQuad(whileQuad)
			print("[DBG]f += <FOREACH " + foreachLabel.name + ", _," + elem + ", " + ensemble + ">\n")
		}
		else
		{
			l.add(whileQuad)
			print("[DBG]" + l.name + " += <FOREACH " + foreachLabel.name + ", _," + elem + ", " + ensemble + ">\n")
		}
		c.cmdForEach.cmds.compile(f, foreachLabel)
	} 
	default : c.class.name
}
»'''

	def compile (Expr ex, Fonction f)
	'''«switch(ex){
			case ex.exprSimp!=null : ex.exprSimp.compile(f)
			case ex.exprAnd!=null : ex.exprAnd.compile(f)
	    }
	 »'''
	
	def compile (ExprSimple ex, Fonction f)
	 '''«switch(ex){
	 	case ex.nil!=null : {
	 		val variable = generateVar
	 		val quadruplet = new Quadruplet(new CodeOp(CodeOp.OP_AFF), variable, "nil", "_")
	 		this.varNameTranslation.put(variable, quadruplet)
	 		print("[DBG]" + variable + " := nil\n")
	 		variable
	 	}
	 	case ex.vari!=null : {
	 		val variable = generateVar
	 		val quadruplet = new Quadruplet(new CodeOp(CodeOp.OP_AFF), variable, ex.vari, "_")
	 		this.varNameTranslation.put(variable, quadruplet)
	 		print("[DBG]" + variable + " := " + ex.vari + "\n")
	 		variable
	 	}
	 	case ex.symb!=null : {
	 		print("symb")
	 		val variable = generateVar
	 		val quadruplet = new Quadruplet(new CodeOp(CodeOp.OP_AFF), variable, ex.symb, "_")
	 		this.varNameTranslation.put(variable, quadruplet)
	 		print("[DBG]" + variable + " := " + ex.symb + "\n")
	 		variable
	 	}
	 	case ex.exprCons!=null : {
	 		print("cons")
	 		val variable = generateVar
	 		//TODO: Don't work (pas de compile(f) pour la liste)
	 		val quadruplet = new Quadruplet(new CodeOp(CodeOp.OP_CONS), variable, ex.exprCons.exprConsAtt1.compile(f).toString, ex.exprCons.exprConsAttList.consList.toString())
	 		this.varNameTranslation.put(variable, quadruplet)
	 		print("[DBG] CONS... but don't work yet\n")
	 		variable
	 	}
	 	case ex.exprHead!=null : {
	 		val variable = generateVar
	 		val res = ex.exprHeadAtt.compile(f).toString
	 		val quadruplet = new Quadruplet(new CodeOp(CodeOp.OP_HD), variable, res, "_")
	 		this.varNameTranslation.put(variable, quadruplet)
	 		print("[DBG]" + variable + " := (hd " + res + ")\n")
	 		variable
	 	}
	 	case ex.exprTail!=null : {
	 		val variable = generateVar
	 		val res = ex.exprTailAtt.compile(f).toString
	 		val quadruplet = new Quadruplet(new CodeOp(CodeOp.OP_TL), variable, res, "_")
	 		this.varNameTranslation.put(variable, quadruplet)
	 		print("[DBG]" + variable + " := (tl " + res + ")\n")
	 		variable
	 	}
	 	case ex.nomSymb!=null : {
	 		print("[DBG]TODO\n")
	 		""
	 	}//TODO: (c'est quoi ?) :"(" + ex.nomSymb + ex.symbAtt.compile(0) + ")"
	 }
	 »'''
	
	//ajouter la variable dans sa fonction
	def compile(Vars v, Fonction f)
	//TODO
'''«IF v.eContents.empty»
		«FOR in : v.varGen»
			«var vari = new Variable (in.toString, "intern")»
			«dico.putVariable(vari, f)»
			«vari.getM_name»
		«ENDFOR»
	«ELSE»_
	«ENDIF»
'''

	def compile(Exprs e, Fonction f)
'''«FOR in : e.expGen»«in.compile(f)»«ENDFOR»'''
		
	def compile (ExprAnd ex, Fonction f)
	'''«ex.exprOr.compile(f)»«IF ex.exprAnd!=null»«ex.exprAndAtt.compile(f)»«ENDIF»'''
	
	def compile (ExprOr ex, Fonction f)
	'''«ex.exprNot.compile(f)»«IF ex.exprOr!=null»«ex.exprOrAtt.compile(f)»«ENDIF»'''
	
	def compile (ExprNot ex, Fonction f)
	'''«IF ex.not!=null»«ENDIF»«ex.exprEq.compile(f)»'''
	
	def compile (ExprEq ex, Fonction f)
	'''«IF ex.expr!=null»(«ex.expr.compile(f)»)«ELSE»«ex.exprSim1.compile(f)»«ex.exprSim2.compile(f)»«ENDIF»'''
}